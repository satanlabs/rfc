<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129b" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
      <meta name="DC.Identifier" content="urn:ietf:rfc:1868" />
      <meta name="DC.Relation.Replaces" content=""/><meta name="DC.Creator" content="G. Malkin"><meta name="DC.Date.Issued" content="November, 1995"/>
       <meta name="DC.Title" content=" ARP Extension - UNARP "/>
       <title>RFC 1868:  ARP Extension - UNARP </title>    
        

        <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->    <script type="text/javascript"><!--
    function addHeaderTags() {
        var spans = document.getElementsByTagName("span");
        for (var i=0; i < spans.length; i++) {
            var elem = spans[i];
            if (elem) {
                var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";               
                }
            }
        }
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script><span class="pre noprint docinfo">[<a href="https://www.rfc-editor.org" title="RFC Editor">RFC Home</a>] [<a href=/rfc/rfc1868.txt>TEXT</a>|<a href=/rfc/pdfrfc/rfc1868.txt.pdf>PDF</a>|<a href=/rfc/rfc1868.html>HTML</a>] [<a href='https://datatracker.ietf.org/doc/rfc1868' title='IETF Datatracker information for this document'>Tracker</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=1868&submit=rfc" title="IPR disclosures related to this document">IPR</a>]                              </span><br/><span class="pre noprint docinfo">                                                                        </span><br /><span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br /><span class="pre noprint docinfo">                                                                        </span><pre>Network Working Group                                          G. Malkin
Request For Comments: 1868                                Xylogics, Inc.
Category: Experimental                                     November 1995


                         <span class="h1">ARP Extension - UNARP</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  This memo does not specify an Internet standard of any
   kind.  Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Abstract

   The Address Resolution Protocol allows an IP node to determine the
   hardware (datalink) address of a neighboring node on a broadcast
   network.  The protocol depends on timers to age away old ARP entries.
   This document specifies a trivial modification to the ARP mechanism,
   not the packet format, which allows a node to announce that it is
   leaving the network and that all other nodes should modify their ARP
   tables accordingly.

Acknowledgements

   Thanks to James Carlson/Xylogics for reviewing this document and
   proposing the backwards compatibility mechanism.

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>. Introduction</span>

   The primary purpose of the Address Resolution Protocol, as defined in
   [<a href="#ref-1" title="&quot;An Ethernet Address Resolution Protocol&quot;">1</a>], is to determine a node's hardware address based on its network
   address (protocol address in ARPspeak).  The ARP protocol
   specifically states that nodes should not periodically advertise
   their existence for two reasons: first, this would generate a lot of
   network traffic and table maintenance overhead; second, it is highly
   unlikely that all nodes will need to communicate to all other nodes.
   Since a node does not advertise its existence, neither does it
   advertise its imminent departure.  This is not a serious problem
   since most ARP implementations maintain timers to age away old
   entries, and departing nodes seldom depart gracefully in any case.

   Over time, an additional use has been found for ARP: Proxy ARP.
   While there are those who believe Proxy ARP is an evil thing, it does
   serve a purpose; that is, it allows for communication in ways never
   considered in the original IP architecture.  For example, allows
   dial-in hosts to connect to a network without consuming a large



<span class="grey">Malkin                        Experimental                      [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="./rfc1868">RFC 1868</a>                         UNARP                     November 1995</span>


   amount of the IP address space (i.e., all of the hosts contain
   addresses on the same subnet, even though they are not directly
   attached to the physical network associated with that subnet address.
   It is this use of Proxy ARP which produces the problem addressed by
   this document.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>. The Problem</span>

   Consider the following topology:

                    +--------+
                    | Host A |
                    +--------+
                        |
      ======================================== LAN
          |                             |
      +--------+                    +--------+
      |  CS1   |   comm. servers    |  CS2   |
      +--------+                    +--------+
        |    |                        |    |
       +-+  +-+                      +-+  +-+
       | |  | |       modems         | |  | |
       +-+  +-+                      +-+  +-+

   Assume that all of the modems are on the same rotary; that is, when a
   remote host dials in, it may be assigned a modem on either of the
   communication servers.  Further assume that all of the remote hosts'
   IP addresses have the same subnet address as the servers and Host A,
   this in order to conserve address space.

   To begin, a remote host dials into CS1 and attempts to communicate
   with Host A.  Host A will assume, based on the subnet mask, that the
   remote host is actually attached to the LAN and will issue an ARP
   Request to determine its hardware address.  Naturally, the remote
   host will not hear this request.  CS1, knowing this, will respond in
   the remote host's place with its own hardware address.  Host A, on
   receiving the ARP Reply, will then communicate with the remote host,
   transparently through CS1.  So far everything is just fine.

   Now, the remote host disconnects and, before Host A can age its ARP
   cache, reconnects through CS2.  Herein lies the problem.  Whenever
   Host A attempts to send a packet to the remote host, it will send it
   to CS1 because it cannot know that its ARP cache entry is invalid.
   If, when the remote host disconnects, the server to which it was
   attached could inform other nodes on the LAN that the protocol
   address/hardware address mapping was no longer valid, the problem
   would not occur.




<span class="grey">Malkin                        Experimental                      [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="./rfc1868">RFC 1868</a>                         UNARP                     November 1995</span>


<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>. The Solution</span>

   When a server, as described above, disconnects from a remote host for
   which it has responded to a Proxy ARP, it broadcasts an UNARP.  An
   UNARP is an unsolicited ARP Reply with the following field values:

      Hardware Address Space       as appropriate
      Protocol Address Space       0x800 (IP)
      Hardware Address Length      0 (see Backwards Compatibility)
      Protocol Address Length      4 (length of an IP address)
      Opcode                       2 (Reply)
      Source Hardware Address      Not Included
      Source Protocol Address      IP address of detaching host
      Target Hardware Address      Not Included
      Target Protocol Address      255.255.255.255 (IP broadcast)

      NOTE: this is a 16-byte packet (not including MAC header)

   On receiving an UNARP, a node deletes the ARP cache entry associated
   with the IP address.

   It is not strictly necessary that a server keep state information
   about whether or not it has actually sent a Proxy ARP Reply; it would
   be sufficient if a server always sends an UNARP when a remote host
   disconnects.

   Of course, there is no reason why a host which gracefully detaches
   from a LAN cannot also send an UNARP for itself.  This would be
   especially useful if, upon re-attaching, it might have a different
   hardware address.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>. Backwards Compatibility</span>

   The modifications to support UNARP are trivial, so there is every
   expectation that it will be widely supported.  Of course, there will
   be a period of time during which nodes which support UNARP will
   coexist with nodes which do not support UNARP.  To prevent
   unenlightened nodes from adding spurious ARP cache entries with
   hardware addresses of zero, UNARP packets specify a hardware address
   length of zero.  This should be rejected by nodes which do not
   support UNARP.  As a consequence of this, the source and target
   hardware address fields do not exist in UNARP packets (as previously
   described).

   It is recommended that implementors include a configuration switch to
   disable UNARP in the event that some vendor's ARP implementation
   might take offense at the abbreviated UNARP packet format.




<span class="grey">Malkin                        Experimental                      [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="./rfc1868">RFC 1868</a>                         UNARP                     November 1995</span>


<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>. Security Considerations</span>

   Security issues are not discussed in this memo.

References

   [<a id="ref-1">1</a>] Plummer, D., "An Ethernet Address Resolution Protocol", STD 37,
       <a href="./rfc826">RFC 826</a>, MIT, November 1982.

Author's Address

   Gary Scott Malkin
   Xylogics, Inc.
   53 Third Avenue
   Burlington, MA  01803

   Phone:  (617) 272-8140
   EMail:  gmalkin@xylogics.com

































Malkin                        Experimental                      [Page 4]
</pre>
