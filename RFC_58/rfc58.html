<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129b" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
      <meta name="DC.Identifier" content="urn:ietf:rfc:58" />
      <meta name="DC.Relation.Replaces" content=""/><meta name="DC.Creator" content="T.P. Skinner"><meta name="DC.Date.Issued" content="June, 1970"/>
       <meta name="DC.Title" content=" Logical Message Synchronization "/>
       <title>RFC 58:  Logical Message Synchronization </title>    
        

        <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->    <script type="text/javascript"><!--
    function addHeaderTags() {
        var spans = document.getElementsByTagName("span");
        for (var i=0; i < spans.length; i++) {
            var elem = spans[i];
            if (elem) {
                var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";               
                }
            }
        }
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script><span class="pre noprint docinfo">[<a href="https://www.rfc-editor.org" title="RFC Editor">RFC Home</a>] [<a href=/rfc/rfc58.txt>TEXT</a>|<a href=/rfc/pdfrfc/rfc58.txt.pdf>PDF</a>|<a href=/rfc/rfc58.html>HTML</a>] [<a href='https://datatracker.ietf.org/doc/rfc58' title='IETF Datatracker information for this document'>Tracker</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=58&submit=rfc" title="IPR disclosures related to this document">IPR</a>]                              </span><br/><span class="pre noprint docinfo">                                                                        </span><br /><span class="pre noprint docinfo">                                                                 UNKNOWN</span><br /><span class="pre noprint docinfo">                                                                        </span><pre>Network Working Group                                      T. P. Skinner
Request for Comments: 58                                 MIT Project MAC
                                                               June 1970

                    <span class="h1">Logical Message Synchronization</span>


At the last network meeting, the question of logical and physical
message distinctions was raised.  An argument was made in favor of
never running two logical messages together as one or more physical
messages.  Another method of stating this is that a logical message
must begin on a physical message boundary.  This did not, however,
solve the problem of locating the end of a logical message.  A rather
poor technique was suggested by myself which consisted of using the
first partial physical message as an indication of the last physical
message of the logical message.  This technique was thrown out for a
number of very valid reasons.  The solution that seemed most pleasing
was the inclusion of some sort of a bit count or data type
specification to precede the logical message.  Most everyone seemed to
like this even though it was stated in a very general way.

As of this writing it appears that it is desired to completely sever
the relation between physical and logical messages.  This certainly is
aesthetically pleasing.  However, we are now forced to view the
network as a virtually infinite bit stream with no physical
delineations.  It may well do to transmit a logical header and bit
count for each message as long as there are no errors along the line.
If, however, a bit is dropped, the problem of synchronization is
compounded by the fact that we have no ability to search for the
beginning of a logical message other than brute force.  An error of
this type could be introduced by faulty host or user software/hardware
as well as the imp itself.  This would involve the shifting of the
message bit by bit and seeing if the data looked reasonable.  This
could certainly be time-consuming as well as introducing the
possibility of false synchronism.

I can think of several solutions to the problem at the moment.  None
of them seems to be very good.  Upon losing synchronism, a user could
send some form of error message to the other host.  The other host
could then in return cease sending and wait for a message to continue
from the troubled user.  This would allow the troubled user to flush
out all waiting input.  He would then be assured that the next bit
started a logical message.  The problems here are in assuring
synchrony due to input/output buffering in the network and at both
hosts.  How, for example, can the troubled host be assured he has all
the pending data?  Once he is sure, he can then resume input assuming
all is OK.




<span class="grey">                                                                [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey">Another partial solution requires the original restriction that</span>
logical messages always start on physical boundaries.  A user then
merely has to examine the beginning of each physical message to see if
it fits the pattern of a logical message header.  This technique is a
lot safer than examining the entire input stream as well as being
quite a bit faster.

I have not intended to suggest a solution to the problem, but merely
bring it to light.  If we want to restrict logical messages to begin
on physical boundaries we must plan this early in the game.  (It
probably works out that way in most cases anyway.)  Other schemes can
be tried later.  We must, however, face up to this problem fairly
soon.



       [ This RFC was put into machine readable form for entry ]
        [ into the online RFC archives by Carl Alexander 7/97 ]

































                                                                [Page 2]
</pre>
