<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129b" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
      <meta name="DC.Identifier" content="urn:ietf:rfc:505" />
      <meta name="DC.Relation.Replaces" content=""/><meta name="DC.Creator" content="M.A. Padlipsky"><meta name="DC.Date.Issued" content="June, 1973"/>
       <meta name="DC.Title" content=" Two solutions to a file transfer access problem "/>
       <title>RFC 505:  Two solutions to a file transfer access problem </title>    
        

        <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->    <script type="text/javascript"><!--
    function addHeaderTags() {
        var spans = document.getElementsByTagName("span");
        for (var i=0; i < spans.length; i++) {
            var elem = spans[i];
            if (elem) {
                var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";               
                }
            }
        }
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script><span class="pre noprint docinfo">[<a href="https://www.rfc-editor.org" title="RFC Editor">RFC Home</a>] [<a href=/rfc/rfc505.txt>TEXT</a>|<a href=/rfc/pdfrfc/rfc505.txt.pdf>PDF</a>|<a href=/rfc/rfc505.html>HTML</a>] [<a href='https://datatracker.ietf.org/doc/rfc505' title='IETF Datatracker information for this document'>Tracker</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=505&submit=rfc" title="IPR disclosures related to this document">IPR</a>]                              </span><br/><span class="pre noprint docinfo">                                                                        </span><br /><span class="pre noprint docinfo">                                                                 UNKNOWN</span><br /><span class="pre noprint docinfo">                                                                        </span><pre>Network Working Group                                    M. A. Padlipsky
Request for Comments: 505                                    MIT-Multics
NIC: 16156                                                  25 June 1973


            <span class="h1">Two Solutions to a File Transfer Access Problem</span>

   In RFC #87, Bob Bressler raises the issue of how one can use the File
   Transfer Protocol to send a file to a user on another system without
   knowing that user's password.  In <a href="./rfc501">RFC 501</a>, Kan Pogran points out
   certain objections to Bressler's solution of having a "daemon"
   process do the job -- in particular, the fact that it would require
   an interpretive access control mechanism in the daemon different from
   most system's normal access control mechanisms.  Because Ken felt
   that it would be too much of a digression in <a href="./rfc501">RFC 501</a> for him to cover
   the following points fully, I decided it might be of interest to deal
   with them separately: There are at least two solutions to the problem
   Bob raised in <a href="./rfc487">RFC 487</a> -- in regard to "my" sending "him" a file
   without knowing his password -- which don't give rise to the problems
   noted in <a href="./rfc501">RFC 501</a>.  One hinges on adding a convention to the FTP, the
   other on adding a command.

   The first solution is very straightforward.  Instead of having me
   push the file, he could pull it.  That is, he uses his own "principal
   identifies" (thus solving access permission problems at his end) and
   his own User FTP to extract the file with the aid of my Server FTP.
   All this requires is that 1) I give appropriate access permission on
   my end, and 2) he have the ability to use my Server FTP.  The second
   condition is met by either a) his having an account on my system, or
   b) my system's having a known account for "free" Server FTP use. (*)

   So standing the model on its head solves the functional problem,
   although he has to pay for the User FTP.  But, then, it's he who
   wants the file, so why shouldn't he?  On the other hand, "he" might
   not be logged in right now and I might be -- and by the time he can
   get logged in my system might be scheduled to be down.  Fortunately,
   there's also a moderately straightforward solution to the problem as
   originally posed.  This goes back to the mechanism used to prevent
   capricious and/or malicious card input on Multics: Instead of placing
   input (card deck or transferred file) directly into the alleged
   recipient's directory, place it in a "pool" directory and merely
   inform the recipient of its arrival.  If he really wanted it, he then
   copies it into his own directory.  That way, unauthorized people
   can't freeload on somebody else's directory (and the pool is, of
   course, periodically purged), nor can they clobber others' already-
   existing files.





<span class="grey">Padlipsky                                                       [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="./rfc505">RFC 505</a>        Two Solutions to a File Transfer             25 June 1973</span>


[<a id="ref-1">1</a>]

   This second solution has the virtue of requiring fewer steps than the
   first, and would work even when the first wouldn't; so even though it
   would require another FTP command, I propose the addition of a new
   FTP "POOL" command, which does what the last paragraph described.
   Depending on the various Servers' protection mechanisms, the pooled
   files could be made readable only by the declared recipients.  This
   would, for example, offer an easy way to get some privacy for "mail"
   (which otherwise is likely to be readable by anybody who can write
   it), although other solutions to that particular problem of course
   exist.  At any rate, the POOL command's syntax would be POOL id name
   where id is a valid user identifier on the Server, and name is the
   desired name to be placed on the about-to-be-transferred file in the
   Server's pool directory.  (*) (Servers must, of course, do whatever
   pre- or post-fixing to name is necessary to make it unique within the
   pool.)  The transfer then takes place in the same manner as with
   STOR, and on successful completion the Server sends a message to id
   that he should pick up name (suitably) modified to look like a local
   pathname) if he wants it. The message should also identify the
   putative sender (even though it might have come in from a free
   account).  The id should, naturally, be validated before starting the
   transfer.

   The question has been raised locally as to why we don't simply take a
   pooled view of STOR on Multics and forget about pushing for a new
   command.  To do so would have two drawbacks, I feel: first, I think
   we'd be remiss in our duty as NWG participants if we failed to
   attempt to offer solutions to protocol problems to the Network
   community as a whole.  Second, on a less pious but more practical
   note, if we don't know the id we have to infer it from the pathname,
   which rules out abbreviations and forces senders to have to know too
   much  about our internal structure. (The alternative of requiring an
   additional argument to the STOR is subject to the same objection.  It
   is also subject to the objection that protocols really shouldn't be
   unilaterally extended.  Of course, we could go to "site-specific
   parameters", but that's complicating life so much that the
   alternative of no unsolicited files seems preferable.)  Therefore, I
   think that POOL would be worthwhile unless no other Servers have
   enough access control for it to be necessary anywhere but on Multics.
   At the very least, having the protocol specify an "access id"
   optional argument to STOR seems desirable.

[<a id="ref-2">2</a>]

   Input as to whether any of the other Servers has file access control
   abilities similar to those of Multics would be useful in clarifying
   whether this whole area is one which needs specific treatment at the



<span class="grey">Padlipsky                                                       [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="./rfc505">RFC 505</a>        Two Solutions to a File Transfer             25 June 1973</span>


   Protocol level, or merely needs internally acceptable handling at our
   end.  In the meantime, if you're trying to send an unsolicited file
   to us for free, you can use the NETML mechanism with no directory
   qualification on the target pathname in the STOR, then MAIL the file
   name to the intended recipient, who will copy the file into his own
   directory (from, in our syntax, &gt;udd&gt;Cnet&gt;anonymous).  That's all
   pretty complicated, but it sure does go to show that higher-level
   protocols need to know an awful lot about the various operating
   systems.  At any rate, comment on either Bressler's Problem, POOL,
   STOR, or other people's access control mechanisms would all be
   appreciated.

Endnotes

   [<a id="ref-1">1</a>] (*) For b),I suggest that the USER NETML / PASS NETML discipline
   of <a href="./rfc491">RFC 491</a> be extended.  That is, Hosts which allow free use of their
   FTP Servers should accept that pair of FTP commands as an indication
   to commence free service.  Whether this leads to a login of a dummy
   user or a passoff to a daemon process is a matter of local
   implementation preference, of course.

   [<a id="ref-2">2</a>] (*) Note that this definition relieves the user of having to know
   the Server's pathname for the pool directory.


         [ This RFC was put into machine readable form for entry ]
          [ into the online RFC archives by Thomas Farmer 11/98 ]
























Padlipsky                                                       [Page 3]
</pre>
